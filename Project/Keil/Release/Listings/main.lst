C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Release\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\main.c OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X8000) INCDIR(..\..
                    -\Libraries\Include;..\..\User;..\..\Hardware;..\..\App) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\main.lst
                    -) OBJECT(.\Release\Objects\main.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    main.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    01-05-2021
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2021 HUGE-IC</center></h2>
  12           *
  13           * 版权说明后续补上
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          #include "include.h"
  19          #include "my_config.h"
  20          
  21          volatile bit flag_bat_is_empty = 0; // 标志位，用于检测是否拔出了电池
  22          volatile bit flag_bat_is_full = 0;  // 电池是否被充满电的标志位
  23          
  24          volatile bit flag_is_in_charging = 0;             // 是否处于充电的标志位
  25          volatile bit flag_tim_scan_maybe_not_charge = 0;  // 用于给定时器扫描的标志位，可能检测到了拔出充电器
  26          volatile bit flag_tim_scan_maybe_in_charging = 0; // 用于给定时器扫描的标志位，可能检测到了充电器
  27          volatile bit flag_tim_set_is_in_charging = 0;     // 由定时器置位/复位的，表示是否有插入充电器的标志位
  28          volatile bit flag_tim_scan_bat_maybe_full = 0;    // 用于给定时器扫描的标志位，可能检测到电池被充满电
  29          volatile bit flag_tim_set_bat_is_full = 0;        // 由定时器置位/复位的，表示电池是否被充满电的标志位
  30          
  31          volatile bit flag_tim_scan_maybe_low_bat = 0; // 用于给定时器扫描的标志位，可能检测到了低电量
  32          volatile bit flag_tim_set_bat_is_low = 0;     // 由定时器置位/复位的，表示在工作时，电池是否处于低电量的标
             -志位
  33          
  34          volatile bit flag_tim_scan_maybe_shut_down = 0; // 用于给定时器扫描的标志位，可能检测到了 电池电压 低于 关
             -机对应的电压
  35          volatile bit flag_tim_set_shut_down = 0;        // 由定时器置位/复位的，表示在工作时，检测到了 电池电压 在
             -一段时间内都低于 关机对应的电压
  36          
  37          volatile bit flag_tim_scan_maybe_motor_stalling = 0; // 用于给定时器扫描的标志位，可能检测到了电机堵转
  38          volatile bit flag_tim_set_motor_stalling = 0;        // 由定时器置位/复位的，表示在工作时检测到了电机堵转
  39          
  40          volatile bit flag_is_enable_key_scan = 0; // 标志位，是否使能按键扫描(每10ms被定时器置位，在主函数中检测并
             -清零)
  41          volatile bit flag_is_dev_open = 0;        // 设备是否开机的标志位，0--未开机，1--开机
  42          
  43          volatile bit flag_ctl_led_blink = 0; // 控制标志位，是否控制指示灯闪烁
  44          volatile bit flag_ctl_turn_dir = 0;  // 控制标志位，是否更换电机的方向
  45          
  46          volatile bit flag_ctl_dev_close = 0; // 控制标志位，是否要关闭设备
  47          
  48          volatile bit flag_ctl_low_bat_alarm = 0; // 控制标志位，是否使能低电量报警
  49          
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 2   

  50          volatile bit flag_is_disable_to_open = 0; // 标志位，是否不使能开机(低电量不允许开机)
  51          
  52          // 控制函数，开机
  53          void fun_ctl_power_on(void)
  54          {
  55   1          alter_motor_speed(2); // 开机后，电机进入二档
  56   1      
  57   1          motor_pwm_b_enable(); // 电机正向转动
  58   1      
  59   1          cur_motor_dir = 1;    // 表示当前电机在正转
  60   1          cur_motor_status = 2; // 更新电机挡位状态
  61   1          flag_is_dev_open = 1; // 表示设备已经开启
  62   1      
  63   1          // 让绿灯闪烁
  64   1          LED_GREEN_ON();
  65   1          cur_sel_led = CUR_SEL_LED_GREEN;
  66   1          cur_ctl_led_blink_cnt = cur_motor_status; // led闪烁次数与当前电机的挡位有关
  67   1          flag_ctl_led_blink = 1;                   // 打开LED闪烁的功能
  68   1      }
  69          
  70          // 控制函数，关机
  71          void fun_ctl_power_off(void)
  72          {
  73   1          // alter_motor_speed(0); 关机（好像可以不写这一条）
  74   1      
  75   1          // 关闭灯光闪烁的动画
  76   1          flag_ctl_led_blink = 0;
  77   1          LED_GREEN_OFF();
  78   1          LED_RED_OFF();
  79   1      
  80   1          // 关闭加热
  81   1          cur_ctl_heat_status = 0;
  82   1      
  83   1          // 关闭PWM输出：
  84   1          motor_pwm_disable();
  85   1      
  86   1          cur_motor_status = 0; // 表示电机已经关闭
  87   1          cur_motor_dir = 0;    // 清零，回到初始状态
  88   1          flag_is_dev_open = 0; // 表示设备已经关闭
  89   1      
  90   1          // 关机可能是 充电时进入了关机、低电量进入了关机、手动关机、自动进入了关机
  91   1          // 如果是 充电时进入了关机，不应该清除相应的标志位
  92   1          if (0 == flag_is_in_charging)
  93   1          {
  94   2              // 如果没有在充电，清空跟低电量不开机无关的标志位
  95   2              flag_bat_is_full = 0;
  96   2              flag_tim_scan_maybe_not_charge = 0;
  97   2              flag_tim_scan_maybe_in_charging = 0;
  98   2              flag_tim_scan_bat_maybe_full = 0;
  99   2              flag_tim_scan_maybe_low_bat = 0;
 100   2              flag_tim_scan_maybe_shut_down = 0;
 101   2              flag_is_enable_key_scan = 0;
 102   2              flag_ctl_low_bat_alarm = 0;
 103   2          }
 104   1      }
 105          
 106          /**
 107           * @brief 控制电机挡位
 108           *           如果要根据传参来调节挡位，会改变 全局变量 cur_motor_status 的状态
 109           *
 110           * @param adjust_motor_status 要调节到的挡位
 111           *                          0--根据全局变量 cur_motor_status 的状态来自动调节
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 3   

 112           *                          1--调节为1档
 113           *                          2--调节为2档
 114           *                          3--调节为3档
 115           *                          其他--函数直接返回 （为了节省程序空间，这里没有加）
 116           */
 117          void fun_ctl_motor_status(u8 adjust_motor_status)
 118          {
 119   1      #if 0  // 可以节省5字节空间
                  // if (adjust_motor_status > 3)
                  // {
                  //     return; // 传参有误，直接返回
                  // }
              #endif // 可以节省5字节空间
 125   1      
 126   1          if (0 == adjust_motor_status)
 127   1          {
 128   2              // 如果不是根据传参来调节挡位，
 129   2              // 而是根据全局变量cur_motor_status的状态来调节
 130   2              if (1 == cur_motor_status)
 131   2              {
 132   3                  // 从 1档 -> 2档
 133   3                  cur_motor_status = 2;
 134   3              }
 135   2              else if (2 == cur_motor_status)
 136   2              {
 137   3                  // 从 2档 -> 3档
 138   3                  cur_motor_status = 3;
 139   3              }
 140   2              else if (3 == cur_motor_status)
 141   2              {
 142   3                  // 从 3档 -> 1档
 143   3                  cur_motor_status = 1;
 144   3              }
 145   2          }
 146   1          else
 147   1          {
 148   2              // 如果是根据传参来调节挡位
 149   2              cur_motor_status = adjust_motor_status;
 150   2          }
 151   1      
 152   1          alter_motor_speed(cur_motor_status);
 153   1      
 154   1          // 每次切换挡位，都让定时器加载动画
 155   1          flag_ctl_led_blink = 0; // 打断当前正在闪烁的功能
 156   1      
 157   1          // 如果不处于低电量报警状态，才使能LED闪烁功能：
 158   1          if (0 == flag_tim_set_bat_is_low)
 159   1          {
 160   2              if (0 == cur_ctl_heat_status)
 161   2              {
 162   3                  // 如果没有打开加热，让绿灯闪烁
 163   3                  LED_RED_OFF();
 164   3                  LED_GREEN_ON();
 165   3                  cur_sel_led = CUR_SEL_LED_GREEN;
 166   3              }
 167   2              else
 168   2              {
 169   3                  // 如果打开了加热，让红灯闪烁
 170   3                  LED_GREEN_OFF();
 171   3                  LED_RED_ON();
 172   3                  cur_sel_led = CUR_SEL_LED_RED;
 173   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 4   

 174   2              cur_ctl_led_blink_cnt = cur_motor_status; // led闪烁次数与当前电机的挡位有关
 175   2              flag_ctl_led_blink = 1;                   // 打开LED闪烁的功能
 176   2          }
 177   1      }
 178          
 179          /**
 180           * @brief  Main program.
 181           * @param  None
 182           * @retval None
 183           */
 184          void main(void)
 185          {
 186   1          system_init();
 187   1      
 188   1          // 关闭HCK和HDA的调试功能
 189   1          WDT_KEY = 0x55; // 解除写保护
 190   1          IO_MAP |= 0x03; // 关闭HCK和HDA引脚的调试功能（解除映射）
 191   1          WDT_KEY = 0xBB;
 192   1      
 193   1          // 初始化打印
 194   1      #if USE_MY_DEBUG
                  debug_init();
                  printf("TXM8C101x_SDK main start\n");
              #endif //  #if USE_MY_DEBUG
 198   1      
 199   1          // 初始化 检测按键 的引脚：
 200   1          // 假设用 P11 AIN9 来检测ad按键 （更换板之后是直接检测电平）
 201   1          P1_MD0 |= 0x03 << 2;   // 模拟模式
 202   1          P1_AIOEN |= 0x01 << 1; // 使能模拟功能
 203   1      
 204   1          // 使用 P00 作为 DEBUG 引脚
 205   1          P0_MD0 |= 0x01; // 输出模式
 206   1      
 207   1          heating_pin_config(); // 加热控制引脚
 208   1          led_config();
 209   1          tmr1_config();     // 1ms定时器
 210   1          tmr2_pwm_config(); // 控制升压的PWM
 211   1      
 212   1          adc_config();
 213   1          motor_config(); // 控制电机的两路PWM
 214   1      
 215   1          // 由于芯片下载之后会没有反应，这里用绿色灯作为指示：
 216   1          LED_GREEN_ON();
 217   1          delay_ms(1000);
 218   1          LED_GREEN_OFF();
 219   1      
 220   1      #if 0 // 上电时检测电池是否正确安装(测试通过):
                  /*
                      如果打开PWM后，检测电池的电压比满电还要高，说明没有接入电池，
                      检测到的是充电5V升压后的电压
                  */
                  tmr2_pwm_enable();    // 打开控制升压电路的pwm
                  TMR2_PWML = 93 % 256; // 调节为约47.6%的占空比
                  TMR2_PWMH = 93 / 256;
                  adc_sel_channel(ADC_CHANNEL_BAT); // 切换到检测电池降压后的电压的检测引脚
              
                  {
                      u8 i = 0;
                      u16 adc_val = 0;
                      for (i = 0; i < 10; i++) // 每55ms进入一次，循环内每次间隔约4.8ms
                      {
                          adc_val = adc_get_val();
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 5   

                          if (adc_val >= ADCDETECT_BAT_FULL + ADCDETECT_BAT_NULL_EX)
                          {
                              flag_bat_is_empty = 1; // 表示电池是空的(电池没有安装)
                          }
                      }
                  }
              
                  tmr2_pwm_disable(); // 关闭控制升压电路的PWM
                  TMR2_PWML = 0;      // 0%占空比
                  TMR2_PWMH = 0;
              
              #endif // 上电时检测电池是否正确安装
 248   1        
 249   1          while (1)
 250   1          {  
 251   2              P00 = 1;
 252   2              delay_ms(20);
 253   2              P00 = 0;
 254   2              delay_ms(20);
 255   2      
 256   2      #if 0  // (测试通过)上电时，如果检测到电池没有安装，让LED闪烁，直到重新上电
                      if (flag_bat_is_empty)
                      {
                          // 没有放入电池，控制LED闪烁，直到重新上电
                          LED_RED_ON();
                          delay_ms(200);
                          LED_RED_OFF();
                          delay_ms(200);
                          continue;
                      }
              #endif // 上电时，如果检测到电池没有安装，让LED闪烁，直到重新上电
 267   2      
 268   2      #if 1
 269   2              charge_scan_handle();
 270   2      
 271   2              if (0 == flag_is_in_charging &&   /* 不充电时，才对按键做检测和处理 */
 272   2                  0 == flag_is_disable_to_open) /* 不处于低电量不能开机的状态时 */
 273   2              {
 274   3                  if (flag_is_enable_key_scan) // 每10ms，该标志位会被定时器置位一次
 275   3                  {
 276   4                      flag_is_enable_key_scan = 0;
 277   4                      key_scan_10ms_isr();
 278   4                  }
 279   3      
 280   3                  key_event_handle();
 281   3              }
 282   2              else
 283   2              {
 284   3                  // flag_is_enable_key_scan = 0; // 直接清空标志位
 285   3              }
 286   2      #endif
 287   2      
 288   2      #if 1  // 电机自动转向
 289   2              if (flag_ctl_turn_dir)
 290   2              {
 291   3                  // 如果要切换电机转向
 292   3                  flag_ctl_turn_dir = 0;
 293   3                  if (0 == cur_motor_dir)
 294   3                  {
 295   4                      // 如果当前电机为初始状态，不调节
 296   4                  }
 297   3                  else if (1 == cur_motor_dir)
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 6   

 298   3                  {
 299   4                      // 如果当前电机为正转，调节为反转
 300   4                      // PWM0EC = 0; // 关闭正转的PWM输出
 301   4                      motor_pwm_b_disable(); // 关闭正转的PWM输出
 302   4                      delay_ms(500);
 303   4                      // PWM1EC = 1;        // 打开反转的PWM输出
 304   4                      motor_pwm_a_enable(); // 打开反转的PWM输出
 305   4                      cur_motor_dir = 2;    // 表示电机当前转向为 反转
 306   4                  }
 307   3                  else if (2 == cur_motor_dir)
 308   3                  {
 309   4                      // 如果当前电机为反转，调节为正转
 310   4                      // PWM1EC = 0; // 关闭反转的PWM输出
 311   4                      motor_pwm_a_disable(); // 关闭反转的PWM输出
 312   4                      delay_ms(500);
 313   4                      // PWM0EC = 1;        // 打开正转的PWM输出
 314   4                      motor_pwm_b_enable();
 315   4                      cur_motor_dir = 1; // 表示电机当前转向为 正转
 316   4                  }
 317   3                  else
 318   3                  {
 319   4                      // 其他情况，不考虑，不做处理
 320   4                  }
 321   3              }
 322   2      #endif // 电机自动转向
 323   2      
 324   2      #if 1  // 电机过流检测和处理
 325   2      
 326   2              motor_over_current_detect_handle(); // 函数内部会检测电机有没有运行
 327   2      #endif // 电机过流检测和处理
 328   2      
 329   2      #if 1  // 根据控制标志位来控制关机
 330   2              if (flag_ctl_dev_close)
 331   2              {
 332   3                  // 如果要关闭设备
 333   3                  flag_ctl_dev_close = 0;
 334   3                  fun_ctl_power_off();
 335   3              }
 336   2      #endif // 根据控制标志位来控制关机
 337   2      
 338   2      #if 0 // 检测设备状态，确认设备是否已经开机，并更新相应标志位
                  // （好像可以不用加，自动关机检测那里已经包含了 检测电机和加热的状态）
              
                      // if ((0 != cur_motor_status) || /* 如果电机未关闭 */
                      //     (0 != cur_ctl_heat_status) /* 如果加热未关闭 */
                      // )
                      // {
                      //     flag_is_dev_open = 1; // 表示设备开机
                      // }
              
              #endif
 349   2      
 350   2          } // while (1)
 351   1      }
 352          
 353          void TMR0_IRQHandler(void) interrupt TMR0_IRQn
 354          {
 355   1          if (TMR0_CONH & 0x80)
 356   1          {
 357   2              TMR0_CONH |= 0x80;
 358   2              // 1ms产生一次中断，进入到这里
 359   2      
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 7   

 360   2              if (flag_bat_is_empty)
 361   2              {
 362   3                  return; // 如果电池为空，提前退出中断服务函数
 363   3              }
 364   2      
 365   2              { // 按键扫描
 366   3                  static volatile u8 key_scan_cnt = 0;
 367   3                  key_scan_cnt++;
 368   3                  if (key_scan_cnt >= 10)
 369   3                  {
 370   4                      key_scan_cnt = 0;
 371   4                      flag_is_enable_key_scan = 1;
 372   4                  }
 373   3              } // 按键扫描
 374   2      
 375   2      #if 1 // 检测是否拔出/插入充电器
 376   2      
 377   2              { // 检测是否拔出/插入充电器
 378   3                  static u8 not_charge_ms_cnt = 0;
 379   3                  static u8 charging_ms_cnt = 0;
 380   3                  if (flag_is_in_charging)
 381   3                  {
 382   4                      if (flag_tim_scan_maybe_not_charge)
 383   4                      {
 384   5                          // 正在充电，并且检测到可能有充电器断开，进行计时
 385   5                          not_charge_ms_cnt++;
 386   5                          if (not_charge_ms_cnt >= 50)
 387   5                          {
 388   6                              not_charge_ms_cnt = 0;
 389   6                              flag_tim_set_is_in_charging = 0;
 390   6                          }
 391   5                      }
 392   4                      else
 393   4                      {
 394   5                          // 正在充电，并且没有检测到充电器断开：
 395   5                          not_charge_ms_cnt = 0;
 396   5                          flag_tim_set_is_in_charging = 1;
 397   5                      }
 398   4                  }
 399   3                  else
 400   3                  {
 401   4                      if (flag_tim_scan_maybe_in_charging)
 402   4                      {
 403   5                          // 没有在充电，但是检测到有充电器插入，进行计时，确认充电器是否真的插入：
 404   5                          charging_ms_cnt++;
 405   5                          if (charging_ms_cnt >= 50)
 406   5                          {
 407   6                              charging_ms_cnt = 0;
 408   6                              flag_tim_set_is_in_charging = 1;
 409   6                          }
 410   5                      }
 411   4                      else
 412   4                      {
 413   5                          // 没有在充电，并且也没有检测到充电器插入
 414   5                          charging_ms_cnt = 0;
 415   5                          flag_tim_set_is_in_charging = 0;
 416   5                      }
 417   4                  }
 418   3              } // 检测是否拔出/插入充电器
 419   2      #endif // 检测是否拔出/插入充电器
 420   2      
 421   2      #if 1 // 控制灯光闪烁的效果
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 8   

 422   2      
 423   2              { // 控制灯光闪烁的效果
 424   3      
 425   3                  static volatile u16 blink_ms_cnt = 0; // 计数值，控制灯光闪烁的时间间隔
 426   3      
 427   3                  // 状态机，
 428   3                  // 0--初始值、无状态，
 429   3                  // 1--准备进入闪烁，
 430   3                  // 2--正在闪烁
 431   3                  static volatile u8 cur_blink_status = 0;
 432   3                  static u8 __blink_cnt = 0; // 一开始存放要闪烁的次数，后面控制当前剩余闪烁次数
 433   3      
 434   3                  if (flag_ctl_led_blink)
 435   3                  {
 436   4                      // 如果使能了灯光闪烁
 437   4                      if (0 == cur_blink_status)
 438   4                      {
 439   5                          // 如果当前灯光状态处于初始值，没有在闪烁
 440   5                          cur_blink_status = 1;
 441   5                      }
 442   4                  }
 443   3                  else
 444   3                  {
 445   4                      // 如果不使能灯光闪烁，立即停止当前灯光闪烁的效果
 446   4                      cur_blink_status = 0;
 447   4                      blink_ms_cnt = 0;
 448   4                      __blink_cnt = 0;
 449   4                  }
 450   3      
 451   3                  if (1 == cur_blink_status)
 452   3                  {
 453   4                      // 准备进入闪烁，判断要闪烁的是红灯还是绿灯，是要表示当前电机的挡位还是加热的挡位
 454   4      
 455   4                      // 可以在闪烁前先关闭灯光，再点亮要闪烁的LED，
 456   4                      // 最后再使能闪烁的效果，这样就不用加入下面的判断：
 457   4                      // if (CUR_SEL_LED_RED == cur_sel_led)
 458   4                      // {
 459   4                      //     // 如果要让红灯闪烁
 460   4                      //     // LED_GREEN_OFF();
 461   4                      //     // LED_RED_ON();
 462   4                      // }
 463   4                      // else if (CUR_SEL_LED_GREEN == cur_sel_led)
 464   4                      // {
 465   4                      //     // 如果要让绿灯闪烁
 466   4                      //     // LED_RED_OFF();
 467   4                      //     // LED_GREEN_ON();
 468   4                      // }
 469   4      
 470   4                      // 让灯光保持点亮500ms
 471   4                      blink_ms_cnt++;
 472   4                      if (blink_ms_cnt >= 500)
 473   4                      {
 474   5                          blink_ms_cnt = 0;
 475   5                          cur_blink_status = 2; // 表示正式进入LED闪烁状态
 476   5                      }
 477   4                  }
 478   3                  else if (2 == cur_blink_status)
 479   3                  {
 480   4                      // 如果正在进行LED闪烁
 481   4                      if (0 == __blink_cnt)
 482   4                      {
 483   5                          __blink_cnt = cur_ctl_led_blink_cnt; // 存放当前要闪烁的次数
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 9   

 484   5                      }
 485   4      
 486   4                      if (__blink_cnt) // 如果闪烁次数不为0，继续闪烁
 487   4                      {
 488   5                          blink_ms_cnt++;
 489   5                          if (blink_ms_cnt <= 500)
 490   5                          {
 491   6                              // 熄灭LED 500ms
 492   6                              if (CUR_SEL_LED_RED == cur_sel_led)
 493   6                              {
 494   7                                  // 如果要让红灯闪烁
 495   7                                  LED_RED_OFF();
 496   7                              }
 497   6                              else if (CUR_SEL_LED_GREEN == cur_sel_led)
 498   6                              {
 499   7                                  // 如果要让绿灯闪烁
 500   7                                  LED_GREEN_OFF();
 501   7                              }
 502   6                          }
 503   5                          else if (blink_ms_cnt < 1000)
 504   5                          {
 505   6                              // 点亮LED 500ms
 506   6                              if (CUR_SEL_LED_RED == cur_sel_led)
 507   6                              {
 508   7                                  // 如果要让红灯闪烁
 509   7                                  LED_RED_ON();
 510   7                              }
 511   6                              else if (CUR_SEL_LED_GREEN == cur_sel_led)
 512   6                              {
 513   7                                  // 如果要让绿灯闪烁
 514   7                                  LED_GREEN_ON();
 515   7                              }
 516   6                          }
 517   5                          else
 518   5                          {
 519   6                              blink_ms_cnt = 0;
 520   6                              __blink_cnt--; // 完成了一次闪烁，计数值减一
 521   6                              if (0 == __blink_cnt)
 522   6                              {
 523   7                                  // 如果剩余闪烁次数为0，结束闪烁
 524   7                                  flag_ctl_led_blink = 0; // 不使能闪烁
 525   7                                  cur_blink_status = 0;   // 恢复到初始值，表示没有在闪烁
 526   7                              }
 527   6                          }
 528   5                      }
 529   4                  }
 530   3              } // 控制灯光闪烁的效果
 531   2      #endif // 控制灯光闪烁的效果
 532   2      
 533   2      #if 1 // 控制加热
 534   2      
 535   2              { // 控制加热
 536   3                  static volatile u8 __ctl_heat_ms_cnt = 0;
 537   3      
 538   3                  if (1 == cur_ctl_heat_status)
 539   3                  {
 540   4                      // 一档加热
 541   4                      HEATING_ON();
 542   4                  }
 543   3                  else if (2 == cur_ctl_heat_status)
 544   3                  {
 545   4                      // 二档加热
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 10  

 546   4                      __ctl_heat_ms_cnt++;
 547   4                      if (__ctl_heat_ms_cnt <= 5)
 548   4                      {
 549   5                          HEATING_ON();
 550   5                      }
 551   4                      else if (__ctl_heat_ms_cnt < 10)
 552   4                      {
 553   5                          HEATING_OFF();
 554   5                      }
 555   4                      else
 556   4                      {
 557   5                          __ctl_heat_ms_cnt = 0;
 558   5                      }
 559   4                  }
 560   3                  else
 561   3                  {
 562   4                      // 无状态，关闭加热
 563   4                      HEATING_OFF();
 564   4                      __ctl_heat_ms_cnt = 0;
 565   4                  }
 566   3      
 567   3              } // 控制加热
 568   2      #endif // 控制加热
 569   2      
 570   2      #if 1 // 控制自动关机
 571   2      
 572   2              { // 自动关机
 573   3                  static volatile u32 shut_down_ms_cnt = 0;
 574   3      
 575   3                  if ((0 != cur_motor_status ||     /* 如果电机不是关闭的 */
 576   3                       0 != cur_ctl_heat_status) && /* 如果加热不是关闭的 */
 577   3                      0 == flag_is_in_charging      /* 当前没有在充电 */
 578   3                  )
 579   3                  {
 580   4                      shut_down_ms_cnt++;
 581   4                      if (shut_down_ms_cnt >= 600000) // xx ms 后，关机
 582   4                      {
 583   5                          shut_down_ms_cnt = 0;
 584   5                          flag_ctl_dev_close = 1;
 585   5                      }
 586   4                  }
 587   3                  else
 588   3                  {
 589   4                      shut_down_ms_cnt = 0;
 590   4                  }
 591   3              } // 自动关机
 592   2      #endif // 控制自动关机
 593   2      
 594   2      #if 1     // 控制电机自动换方向
 595   2              { // 自动换方向
 596   3      
 597   3                  static volatile u16 turn_dir_ms_cnt = 0; // 控制在运行时每 xx min切换一次转向的计时变量
 598   3      
 599   3                  if ((0 != cur_motor_status) && /* 如果电机不是关闭的 */
 600   3                      1                          /* 如果没有通过语音调节过方向 */
 601   3                  )
 602   3                  {
 603   4                      turn_dir_ms_cnt++;
 604   4                      if (turn_dir_ms_cnt >= 60000) // xx ms 后，换方向
 605   4                      // if (turn_dir_ms_cnt >= 60) // xx ms 后，换方向（测试用）
 606   4                      {
 607   5                          turn_dir_ms_cnt = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 11  

 608   5                          // 标志位置一，让换方向的操作在主函数执行，因为换方向要间隔500ms
 609   5                          flag_ctl_turn_dir = 1;
 610   5                      }
 611   4                  }
 612   3                  else
 613   3                  {
 614   4                      turn_dir_ms_cnt = 0;
 615   4                  }
 616   3      
 617   3              } // 自动换方向
 618   2      #endif // 控制电机自动换方向
 619   2      
 620   2      #if 1 // 检测是否充满电
 621   2      
 622   2              { // 检测是否充满电
 623   3                  static volatile u16 bat_is_full_ms_cnt = 0;
 624   3                  if (flag_is_in_charging)
 625   3                  {
 626   4                      if (flag_tim_scan_bat_maybe_full)
 627   4                      {
 628   5                          // 正在充电，并且有检测到电池满电，进行累计：
 629   5                          bat_is_full_ms_cnt++;
 630   5                          if (bat_is_full_ms_cnt >= 5000) // xx ms
 631   5                          {
 632   6                              bat_is_full_ms_cnt = 0;
 633   6                              flag_tim_set_bat_is_full = 1;
 634   6                          }
 635   5                      }
 636   4                      else
 637   4                      {
 638   5                          // 正在充电，但是没有检测到电池满电：
 639   5                          bat_is_full_ms_cnt = 0;
 640   5                          flag_tim_set_bat_is_full = 0;
 641   5                      }
 642   4                  }
 643   3              } // 检测是否充满电
 644   2      #endif // 检测是否充满电
 645   2      
 646   2      #if 1 // 检测是否要低电量报警
 647   2      
 648   2              {
 649   3                  static u16 low_bat_ms_cnt = 0;
 650   3                  if (flag_tim_scan_maybe_low_bat)
 651   3                  {
 652   4                      // 如果可能检测到了低电量，进行连续计时
 653   4                      low_bat_ms_cnt++;
 654   4                      if (low_bat_ms_cnt >= LOW_BAT_SCAN_TIMES_MS)
 655   4                      {
 656   5                          low_bat_ms_cnt = 0;
 657   5                          flag_tim_set_bat_is_low = 1;
 658   5                      }
 659   4                  }
 660   3                  else
 661   3                  {
 662   4                      // 如果没有检测到低电量
 663   4                      low_bat_ms_cnt = 0;
 664   4                      flag_tim_set_bat_is_low = 0;
 665   4                  }
 666   3              }
 667   2      
 668   2              { // 根据标志位来执行低电量报警的功能，执行前(给控制标志位置一前)要先关闭所有LED
 669   3      
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 12  

 670   3                  static bit __flag_is_in_low_bat_alarm = 0;   // 标志位，是否正在执行低电量报警的功能
 671   3                  static u16 __blink_cnt_in_low_bat_alarm = 0; // 低电量报警时，LED闪烁时间计数
 672   3      
 673   3                  /* 如果使能了低电量报警，并且设备正在运行 */
 674   3                  if (flag_ctl_low_bat_alarm &&
 675   3                      (0 != cur_motor_status || 0 != cur_ctl_heat_status))
 676   3                  {
 677   4                      if (0 == __flag_is_in_low_bat_alarm)
 678   4                      {
 679   5                          __flag_is_in_low_bat_alarm = 1; // 在该语句块内部，使能低电量报警的功能
 680   5                      }
 681   4                  }
 682   3                  else
 683   3                  {
 684   4                      __blink_cnt_in_low_bat_alarm = 0;
 685   4                      __flag_is_in_low_bat_alarm = 0;
 686   4                  }
 687   3      
 688   3                  if (__flag_is_in_low_bat_alarm)
 689   3                  {
 690   4                      __blink_cnt_in_low_bat_alarm++;
 691   4                      if (__blink_cnt_in_low_bat_alarm <= 300)
 692   4                      {
 693   5                          LED_RED_ON();
 694   5                      }
 695   4                      else if (__blink_cnt_in_low_bat_alarm < 600)
 696   4                      {
 697   5                          LED_RED_OFF();
 698   5                      }
 699   4                      else
 700   4                      {
 701   5                          __blink_cnt_in_low_bat_alarm = 0;
 702   5                      }
 703   4                  }
 704   3              } // 根据标志位来执行低电量报警的功能，执行前(给控制标志位置一前)要先关闭所有LED
 705   2      #endif // 检测是否要低电量报警
 706   2      
 707   2      #if 1 // 工作时，检测电池电量是否一直低于关机电压
 708   2      
 709   2              {
 710   3                  static u16 __shut_down_cnt = 0; // 对电池电压低于关机电压的连续计时
 711   3      
 712   3                  if (flag_tim_scan_maybe_shut_down)
 713   3                  {
 714   4                      // 如果检测到在工作时，电池电压低于关机电压，进行连续计时
 715   4                      __shut_down_cnt++;
 716   4                      if (__shut_down_cnt >= SHUT_DOWN_SCAN_TIMES_MS)
 717   4                      {
 718   5                          __shut_down_cnt = 0;
 719   5                          flag_tim_set_shut_down = 1;
 720   5                      }
 721   4                  }
 722   3                  else
 723   3                  {
 724   4                      // 如果在工作时，没有检测到 电池电压低于关机电压
 725   4                      __shut_down_cnt = 0;
 726   4                      flag_tim_set_shut_down = 0;
 727   4                  }
 728   3              }
 729   2      #endif // 工作时，检测电池电量是否一直低于关机电压
 730   2      
 731   2      #if 1 // 电机过流检测，超过10s便认为电机堵转
C51 COMPILER V9.60.7.0   MAIN                                                              02/15/2025 16:57:43 PAGE 13  

 732   2      
 733   2              {
 734   3                  // 检测到电机堵转后，进行连续计时
 735   3                  static u16 __detect_motor_stalling_cnt = 0;
 736   3      
 737   3                  if (flag_tim_scan_maybe_motor_stalling && 0 != cur_motor_status)
 738   3                  {
 739   4                      // 如果检测到有电机堵转的情况
 740   4                      // P00 = 1;
 741   4      
 742   4                      __detect_motor_stalling_cnt++;
 743   4                      if (__detect_motor_stalling_cnt >= MOTOR_STALLING_SCAN_TIMES_MS)
 744   4                      {
 745   5                          __detect_motor_stalling_cnt = 0;
 746   5                          flag_tim_set_motor_stalling = 1;
 747   5                      }
 748   4                  }
 749   3                  else
 750   3                  {
 751   4                      // 如果没有检测到有电机堵转的情况
 752   4                      // P00 = 0;
 753   4      
 754   4                      __detect_motor_stalling_cnt = 0;
 755   4                      flag_tim_set_motor_stalling = 0;
 756   4                  }
 757   3              }
 758   2      #endif // 电机过流检测，超过10s便认为电机堵转
 759   2          }
 760   1      }
 761          
 762          /**
 763           * @}
 764           */
 765          
 766          /*************************** (C) COPYRIGHT 2021 HUGE-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1011    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     22    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
