C51 COMPILER V9.60.7.0   UART                                                              02/18/2025 17:34:22 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Release\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart.c OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X8000) INCDIR(.
                    -.\..\Libraries\Include;..\..\User;..\..\Hardware;..\..\App) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\uart
                    -.lst) OBJECT(.\Release\Objects\uart.obj)

line level    source

   1          #include "uart.h"
*** WARNING C322 IN LINE 71 OF \BaiduSyncdisk\A_WorkSt\Aworkst\2025-01-22-project250122-ËÕĞÀ-°´Ä¦ÒÇÓïÒô¿î-SX384\code\pro
             -ject-250122-TX8C1011\Libraries\Include\debug.h: unknown identifier
*** WARNING C322 IN LINE 6 OF ..\..\Hardware\motor.h: unknown identifier
*** WARNING C322 IN LINE 26 OF ..\..\App\speech_process.h: unknown identifier
   2          
   3          #include <stdio.h>
   4          
   5          #define USER_UART_BAUD ((SYSCLK - 115200UL) / (115200UL))
   6          
   7          extern volatile bit flag_is_recv_ctl; // æ ‡å¿—ä½ï¼Œæ˜¯å¦æ¥æ”¶äº†æ§åˆ¶å‘½ä»¤
   8          
   9          void uart1_config(void)
  10          {
  11   1          // P00 RX
  12   1          P0_MD0 &= ~0x03;
  13   1          P0_MD0 |= 0x02; // å¤šåŠŸèƒ½IOæ¨¡å¼
  14   1          P0_AF0 &= ~0x03;
  15   1          P0_AF0 |= 0x01; // P00 å¤ç”¨ä¸º UART1_RX
  16   1      
  17   1          __EnableIRQ(UART1_IRQn); // æ‰“å¼€UARTæ¨¡å—ä¸­æ–­
  18   1          IE_EA = 1;               // æ‰“å¼€æ€»ä¸­æ–­
  19   1      
  20   1          UART1_BAUD1 = (USER_UART_BAUD >> 8) & 0xFF; // é…ç½®æ³¢ç‰¹ç‡é«˜å…«ä½
  21   1          UART1_BAUD0 = USER_UART_BAUD & 0xFF;        // é…ç½®æ³¢ç‰¹ç‡ä½å…«ä½
  22   1          UART1_CON = 0x91;                           // 8bitæ•°æ®ï¼Œ1bitåœæ­¢ä½ï¼Œä½¿èƒ½ä¸­æ–­
  23   1          UART1_CON |= 0x02;                          // æ¥æ”¶æ¨¡å¼
  24   1      }
  25          
  26          // å®šä¹‰ä¸²å£æ¥æ”¶çš„çŠ¶æ€æœº
  27          // è¡¨ç¤ºä¸²å£å·²ç»æ¥æ”¶äº†ä»€ä¹ˆç±»å‹çš„æ•°æ®
  28          enum
  29          {
  30              RECV_NONE = 0,
  31              RECV_HEAD,
  32              RECV_CTL,
  33              RECV_TAIL,
  34          };
  35          volatile u8 cur_recv_status = RECV_NONE;
  36          
  37           
  38          static volatile u8 recv_data = 0; // ä¸²å£æ¥æ”¶æ•°æ®ç¼“å†²åŒºï¼Œåªåœ¨å½“å‰æ–‡ä»¶å†…ä½¿ç”¨
  39          volatile u8 recv_ctl = 0;         // å­˜æ”¾æ¥æ”¶å®Œæˆçš„æ§åˆ¶å‘½ä»¤
  40          void UART1_IRQHandler(void) interrupt UART1_IRQn
  41          {
  42   1      // RXæ¥æ”¶å®Œæˆä¸­æ–­
  43   1      #if 0
                  if (UART1_STA & 0x20)
                  {
                      // uart_data = UART1_DATA;
                      // printf("%d\n",uart_data); 
                      // _flag_is_recved_data = 1;
                  }
C51 COMPILER V9.60.7.0   UART                                                              02/18/2025 17:34:22 PAGE 2   

                  UART1_STA |= 0x08; // æ¸…ä¸­æ–­è¯·æ±‚æ ‡å¿—ä½
              #endif
  52   1      
  53   1          if (UART1_STA & 0x20)
  54   1          {
  55   2              if (RECV_NONE == cur_recv_status)
  56   2              {
  57   3                  // å¦‚æœå½“å‰ä»€ä¹ˆéƒ½æ²¡æœ‰æ¥æ”¶ï¼Œå‡†å¤‡æ¥æ”¶åˆ°æ¥çš„æ ¼å¼å¤´
  58   3                  if (FORMAT_HEAD == UART1_DATA)
  59   3                  {
  60   4                      cur_recv_status = RECV_HEAD;
  61   4                  }
  62   3              }
  63   2              else if (RECV_HEAD == cur_recv_status)
  64   2              {
  65   3                  // å¦‚æœå·²ç»æ¥æ”¶äº†æ ¼å¼å¤´
  66   3                  recv_data = UART1_DATA;
  67   3                  cur_recv_status = RECV_CTL; // è¡¨ç¤ºå·²ç»æ¥æ”¶äº†æ§åˆ¶å‘½ä»¤
  68   3              }
  69   2              else if (RECV_CTL == cur_recv_status)
  70   2              {
  71   3                  // å¦‚æœå·²ç»æ¥æ”¶äº†æ ¼å¼å¤´å’Œæ§åˆ¶å‘½ä»¤ï¼Œå¼€å§‹è®¡ç®—æ ¡éªŒ
  72   3                  // æ ¡éªŒ == (æ ¼å¼å¤´ + æ§åˆ¶å‘½ä»¤) & 0xFF
  73   3                  if (((FORMAT_HEAD + recv_data) & 0xFF) == UART1_DATA)
  74   3                  {
  75   4                      // ç»™å¯¹åº”çš„æ ‡å¿—ä½ç½®ä¸€ï¼Œè®©ä¸»å¾ªç¯æ¥æ‰«æå¹¶å¤„ç†å¯¹åº”çš„æ§åˆ¶å‘½ä»¤
  76   4                      // å°†æ§åˆ¶å‘½ä»¤å­˜æ”¾åˆ°å¦å¤–çš„å˜é‡ä¸­ï¼Œä¸å ç”¨ä¸²å£æ¥æ”¶çš„ç¼“å†²
  77   4                      recv_ctl = recv_data;
  78   4                      flag_is_recv_ctl = 1;
  79   4                  }
  80   3                  else
  81   3                  {
  82   4                      // æ ¡éªŒä¸é€šè¿‡
  83   4                      // flag_is_recv_ctl = 0; // å¥½åƒå¯ä»¥ä¸åŠ è¿™ä¸€å¥
  84   4                  }
  85   3      
  86   3                  cur_recv_status = RECV_NONE;
  87   3              }
  88   2          }
  89   1          UART1_STA |= 0x08; // æ¸…ä¸­æ–­è¯·æ±‚æ ‡å¿—ä½
  90   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    103    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
